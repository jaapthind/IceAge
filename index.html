<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTRA PENALTY ELITE 2026</title>
    <style>
        :root { --accent: #00f2ff; --gold: #ffd700; --danger: #ff4444; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* OVERLAY HUD */
        #hud { position: absolute; inset: 0; pointer-events: none; z-index: 10; color: #fff; }
        
        .score-card { position: absolute; top: 40px; left: 40px; background: rgba(0,0,0,0.8); padding: 20px 35px; border-radius: 4px; border-left: 6px solid var(--accent); backdrop-filter: blur(10px); }
        .score-label { font-size: 10px; text-transform: uppercase; letter-spacing: 3px; color: #888; }
        .score-num { font-size: 48px; font-weight: 900; font-style: italic; display: block; }

        /* POWER INDICATOR */
        #power-system { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); width: 350px; opacity: 0; transition: opacity 0.2s; }
        .bar-outer { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 10px; border: 1px solid rgba(255,255,255,0.3); overflow: hidden; }
        #bar-inner { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--gold), var(--danger)); box-shadow: 0 0 20px var(--accent); }

        /* ANNOUNCER */
        #announcer { position: absolute; top: 35%; width: 100%; text-align: center; opacity: 0; transform: scale(0.5); transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #announcer.active { opacity: 1; transform: scale(1.1); }
        .msg { font-size: 100px; font-weight: 900; font-style: italic; -webkit-text-stroke: 2px black; text-transform: uppercase; }
    </style>
</head>
<body>

<div id="hud">
    <div class="score-card">
        <span class="score-label">Streak Scored</span>
        <span id="score-val" class="score-num">0</span>
    </div>

    <div id="announcer">
        <div id="msg-text" class="msg">GOAL!</div>
    </div>

    <div id="power-system">
        <div class="score-label" style="text-align: center; margin-bottom: 10px;">Shot Power</div>
        <div class="bar-outer"><div id="bar-inner"></div></div>
    </div>
</div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

/**
 * ENGINE CONFIGURATION
 */
const SETTINGS = {
    GRAVITY: -0.015,
    AIR_DRAG: 0.993,
    MAGNUS: 0.0006, // Determines how much the ball curves
    BOUNCE: 0.45,
    GOAL_Z: -50,
    BALL_START: new THREE.Vector3(0, 0.55, 15)
};

class GameEngine {
    constructor() {
        this.initCore();
        this.initStadium();
        this.initActors();
        this.initInput();
        this.resetGame();
        
        this.clock = new THREE.Clock();
        this.score = 0;
        this.state = 'READY'; // READY, AIMING, FLIGHT, RESOLVED
        
        this.animate();
    }

    initCore() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x020617);
        this.scene.fog = new THREE.FogExp2(0x020617, 0.012);

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 5, 30);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);

        // Lighting
        const amb = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(amb);

        this.floodlight = new THREE.DirectionalLight(0xffffff, 1.5);
        this.floodlight.position.set(10, 40, 20);
        this.floodlight.castShadow = true;
        this.floodlight.shadow.mapSize.set(2048, 2048);
        this.scene.add(this.floodlight);
    }

    initStadium() {
        // Procedural Grass
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#14532d'; ctx.fillRect(0,0,512,512);
        ctx.fillStyle = '#166534'; ctx.fillRect(0,0,512,256);
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(1, 15);

        const pitch = new THREE.Mesh(new THREE.PlaneGeometry(100, 200), new THREE.MeshStandardMaterial({ map: tex }));
        pitch.rotation.x = -Math.PI / 2;
        pitch.receiveShadow = true;
        this.scene.add(pitch);

        // Goal Structure
        const postMat = new THREE.MeshStandardMaterial({ color: 0xf8fafc, roughness: 0.1 });
        const postGeo = new THREE.CylinderGeometry(0.35, 0.35, 10, 20);
        
        this.goal = new THREE.Group();
        const lp = new THREE.Mesh(postGeo, postMat); lp.position.set(-10, 5, SETTINGS.GOAL_Z);
        const rp = new THREE.Mesh(postGeo, postMat); rp.position.set(10, 5, SETTINGS.GOAL_Z);
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 20.7, 20), postMat);
        bar.rotation.z = Math.PI/2; bar.position.set(0, 10, SETTINGS.GOAL_Z);
        
        [lp, rp, bar].forEach(m => { m.castShadow = true; this.goal.add(m); });
        this.scene.add(this.goal);
    }

    initActors() {
        // The Ball
        this.ball = new THREE.Mesh(
            new THREE.SphereGeometry(0.55, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 })
        );
        this.ball.castShadow = true;
        this.scene.add(this.ball);

        // The Goalkeeper
        this.keeper = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.7, 1.8, 8, 16), new THREE.MeshStandardMaterial({color: 0xef4444}));
        body.position.y = 1.6;
        this.keeper.add(body);
        this.keeper.position.set(0, 0, SETTINGS.GOAL_Z + 1.5);
        this.scene.add(this.keeper);

        // Aimer Trajectory
        this.aimerGeo = new THREE.BufferGeometry();
        this.aimer = new THREE.Line(this.aimerGeo, new THREE.LineBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.5 }));
        this.scene.add(this.aimer);
    }

    initInput() {
        this.dragStart = new THREE.Vector2();
        this.vel = new THREE.Vector3();
        this.spin = 0;

        const onStart = (x, y) => {
            if(this.state !== 'READY') return;
            this.state = 'AIMING';
            this.dragStart.set(x, y);
            document.getElementById('power-system').style.opacity = '1';
        };

        const onMove = (x, y) => {
            if(this.state !== 'AIMING') return;
            const dx = this.dragStart.x - x;
            const dy = this.dragStart.y - y;
            const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.45, 100);
            
            document.getElementById('bar-inner').style.width = power + '%';
            
            // Physics Vector Calculation
            this.vel.set(dx * 0.005, dy * 0.008, -power * 0.02);
            this.spin = dx * 0.0008; // Curve factor
            
            this.updateTrajectory();
        };

        const onEnd = () => {
            if(this.state !== 'AIMING') return;
            this.state = 'FLIGHT';
            document.getElementById('power-system').style.opacity = '0';
            this.aimer.geometry.setFromPoints([]);
            
            // AI Prediction
            const t = Math.abs((SETTINGS.GOAL_Z - this.ball.position.z) / this.vel.z);
            this.keeperX = THREE.MathUtils.clamp(this.ball.position.x + (this.vel.x * t), -9, 9);
        };

        window.addEventListener('pointerdown', e => onStart(e.clientX, e.clientY));
        window.addEventListener('pointermove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('pointerup', onEnd);
    }

    updateTrajectory() {
        const pts = [];
        let p = this.ball.position.clone();
        let v = this.vel.clone();
        for(let i=0; i<40; i++) {
            pts.push(p.clone());
            p.add(v);
            v.y += SETTINGS.GRAVITY;
            if(p.y < 0.55 || p.z < SETTINGS.GOAL_Z) break;
        }
        this.aimer.geometry.setFromPoints(pts);
    }

    resetGame() {
        this.state = 'READY';
        this.ball.position.copy(SETTINGS.BALL_START);
        this.ball.rotation.set(0,0,0);
        this.vel.set(0,0,0);
        this.keeper.position.x = 0;
        this.keeper.rotation.z = 0;
        document.getElementById('announcer').classList.remove('active');
    }

    announce(txt, color) {
        const el = document.getElementById('announcer');
        const m = document.getElementById('msg-text');
        m.innerText = txt;
        m.style.color = color;
        el.classList.add('active');
        setTimeout(() => this.resetGame(), 1800);
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        const dt = this.clock.getDelta() * 60; // Normalize 60fps

        if(this.state === 'FLIGHT') {
            // ADVANCED PHYSICS (Magnus + Drag)
            this.ball.position.add(this.vel.clone().multiplyScalar(dt));
            this.vel.y += SETTINGS.GRAVITY * dt;
            this.vel.multiplyScalar(SETTINGS.AIR_DRAG);
            
            // Side Curve (Magnus Effect)
            this.vel.x += this.spin * this.vel.z * -SETTINGS.MAGNUS * dt;

            // Visual Ball Spin
            this.ball.rotation.x += this.vel.z * 0.4 * dt;
            this.ball.rotation.z -= this.vel.x * 0.4 * dt;

            // Goalkeeper AI Diving
            this.keeper.position.x = THREE.MathUtils.lerp(this.keeper.position.x, this.keeperX, 0.1 * dt);
            if(Math.abs(this.keeperX) > 2) {
                this.keeper.rotation.z = THREE.MathUtils.lerp(this.keeper.rotation.z, (this.keeperX > 0 ? -1.1 : 1.1), 0.1 * dt);
            }

            // Floor Collision
            if(this.ball.position.y < 0.55) {
                this.ball.position.y = 0.55;
                this.vel.y *= -SETTINGS.BOUNCE;
            }

            // Goal/Save Detection
            const distToKeeper = this.ball.position.distanceTo(new THREE.Vector3(this.keeper.position.x, 1.8, this.keeper.position.z));
            if(distToKeeper < 1.8) {
                this.vel.z *= -0.4; this.state = 'RESOLVED';
                this.announce("SAVED!", "#ff4444");
            }

            if(this.ball.position.z < SETTINGS.GOAL_Z) {
                const isGoal = Math.abs(this.ball.position.x) < 10 && this.ball.position.y < 10 && this.ball.position.y > 0.5;
                this.state = 'RESOLVED';
                if(isGoal) {
                    this.score++;
                    document.getElementById('score-val').innerText = this.score;
                    this.announce("GOAL!", "#00f2ff");
                } else {
                    this.announce("MISS!", "#ffffff");
                }
            }

            // Spring Camera
            const camTarget = new THREE.Vector3(this.ball.position.x * 0.4, 6, this.ball.position.z + 15);
            this.camera.position.lerp(camTarget, 0.1 * dt);
        } else {
            this.camera.position.lerp(new THREE.Vector3(0, 5, 25), 0.05 * dt);
        }

        this.camera.lookAt(0, 3, SETTINGS.GOAL_Z + 10);
        this.renderer.render(this.scene, this.camera);
    }
}

new GameEngine();
</script>
</body>
</html>
