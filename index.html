<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTRA Penalty Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial Black', sans-serif; touch-action: none; }
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .hud { position: absolute; color: #fff; text-shadow: 3px 3px 0 #000; font-style: italic; }
        #stats { top: 20px; left: 20px; font-size: 30px; }
        #power-container { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); width: 200px; height: 15px; border: 3px solid #fff; display: none; background: rgba(0,0,0,0.5); }
        #power-fill { height: 100%; width: 0%; background: #facc15; }
        #announcer { position: absolute; top: 30%; width: 100%; text-align: center; font-size: 100px; color: #facc15; display: none; -webkit-text-stroke: 2px black; }
    </style>
</head>
<body>
<div id="ui">
    <div id="stats" class="hud">GOALS: <span id="score">0</span></div>
    <div id="announcer" class="hud">GOAL!</div>
    <div id="power-container"><div id="power-fill"></div></div>
</div>
<canvas id="game"></canvas>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

// --- ARCADE CONFIG (Fast & Snappy) ---
const PHYS = {
    G: -0.05,        // Stronger Gravity
    V_MULT: 0.035,   // Higher Velocity
    BALL_Z: 20,
    GOAL_Z: -30,
    RADIUS: 0.6
};

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x022c22);
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(10, 20, 10);
sun.castShadow = true;
scene.add(sun);

// --- ASSETS ---
// Soccer Ball Pattern (Canvas Texture)
const ballCanvas = document.createElement('canvas');
ballCanvas.width = 256; ballCanvas.height = 256;
const bCtx = ballCanvas.getContext('2d');
bCtx.fillStyle = '#fff'; bCtx.fillRect(0,0,256,256);
bCtx.fillStyle = '#000';
for(let i=0; i<12; i++) { bCtx.beginPath(); bCtx.arc(Math.random()*256, Math.random()*256, 30, 0, 7); bCtx.fill(); }
const ballTex = new THREE.CanvasTexture(ballCanvas);

const ball = new THREE.Mesh(
    new THREE.SphereGeometry(PHYS.RADIUS, 32, 32),
    new THREE.MeshStandardMaterial({ map: ballTex, roughness: 0.3 })
);
ball.castShadow = true;
scene.add(ball);

// Pitch
const pitch = new THREE.Mesh(
    new THREE.PlaneGeometry(200, 200),
    new THREE.MeshStandardMaterial({ color: 0x14532d })
);
pitch.rotation.x = -Math.PI/2;
pitch.receiveShadow = true;
scene.add(pitch);

// Goal (Accurate collision bounds)
const goal = new THREE.Group();
const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
const makePost = (w,h,d,x,y,z) => {
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), postMat);
    m.position.set(x,y,z); m.castShadow = true; goal.add(m);
};
makePost(0.4, 8, 0.4, -8, 4, PHYS.GOAL_Z); // Left
makePost(0.4, 8, 0.4, 8, 4, PHYS.GOAL_Z);  // Right
makePost(16.4, 0.4, 0.4, 0, 8, PHYS.GOAL_Z); // Top
scene.add(goal);

// Goalkeeper
const goalie = new THREE.Mesh(
    new THREE.CapsuleGeometry(0.6, 1.2, 8, 16),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
);
scene.add(goalie);

// Aimer (The precise one)
const aimerGeo = new THREE.BufferGeometry();
const aimerLine = new THREE.Line(aimerGeo, new THREE.LineBasicMaterial({ color: 0xfff000 }));
scene.add(aimerLine);

// --- LOGIC ---
let isDragging = false, isShot = false, score = 0;
let dragStart = new THREE.Vector2(), vel = new THREE.Vector3();
let goalieTargetX = 0;

const reset = () => {
    isShot = false;
    ball.position.set(0, PHYS.RADIUS, PHYS.BALL_Z);
    vel.set(0,0,0);
    goalie.position.set(0, 1.5, PHYS.GOAL_Z + 0.5);
    goalie.rotation.z = 0;
    document.getElementById('announcer').style.display = 'none';
};

const getTrajectoryPoints = (startPos, startVel) => {
    const pts = [];
    let p = startPos.clone();
    let v = startVel.clone();
    for(let i=0; i<40; i++) {
        pts.push(p.clone());
        p.add(v);
        v.y += PHYS.G;
        if(p.y < PHYS.RADIUS || p.z < PHYS.GOAL_Z) break;
    }
    return pts;
};

// --- INPUT ---
window.addEventListener('pointerdown', (e) => {
    if(isShot) return;
    isDragging = true;
    dragStart.set(e.clientX, e.clientY);
    document.getElementById('power-container').style.display = 'block';
});

window.addEventListener('pointermove', (e) => {
    if(!isDragging) return;
    const dx = dragStart.x - e.clientX;
    const dy = dragStart.y - e.clientY;
    const power = Math.min(Math.sqrt(dx*dx + dy*dy), 250);
    
    // Exact velocity mapping
    vel.set(dx * 0.0015, dy * 0.0025, -power * PHYS.V_MULT);
    
    document.getElementById('power-fill').style.width = (power/250)*100 + '%';
    aimerLine.geometry.setFromPoints(getTrajectoryPoints(ball.position, vel));
});

window.addEventListener('pointerup', () => {
    if(!isDragging) return;
    isDragging = false;
    isShot = true;
    document.getElementById('power-container').style.display = 'none';
    aimerLine.geometry.setFromPoints([]);
    
    // AI predicts the X landing
    const time = (PHYS.GOAL_Z - ball.position.z) / vel.z;
    goalieTargetX = THREE.MathUtils.clamp(ball.position.x + (vel.x * time), -7, 7);
});

// --- MAIN LOOP ---
function update() {
    requestAnimationFrame(update);

    if(isShot) {
        ball.position.add(vel);
        vel.y += PHYS.G;
        ball.rotation.x += vel.z * 0.5;

        // Fast Floor Bounce
        if(ball.position.y < PHYS.RADIUS) {
            ball.position.y = PHYS.RADIUS;
            vel.y *= -0.3;
        }

        // Pro Goalie Dive
        goalie.position.x = THREE.MathUtils.lerp(goalie.position.x, goalieTargetX, 0.15);
        if(Math.abs(goalieTargetX) > 1.5) {
            goalie.rotation.z = THREE.MathUtils.lerp(goalie.rotation.z, goalieTargetX > 0 ? -1.2 : 1.2, 0.2);
        }

        // Collision Check
        const dist = ball.position.distanceTo(goalie.position);
        if(dist < 1.5) {
            vel.z *= -0.5; vel.x += (Math.random()-0.5);
        }

        // Goal Detection
        if(ball.position.z < PHYS.GOAL_Z && document.getElementById('announcer').style.display === 'none') {
            const hit = Math.abs(ball.position.x) < 8 && ball.position.y < 8 && ball.position.y > 0;
            const announce = document.getElementById('announcer');
            announce.style.display = 'block';
            if(hit) {
                score++;
                document.getElementById('score').innerText = score;
                announce.innerText = "GOAL!";
                announce.style.color = "#facc15";
            } else {
                announce.innerText = "MISS!";
                announce.style.color = "#ff4444";
            }
            setTimeout(reset, 1500);
        }

        camera.position.lerp(new THREE.Vector3(ball.position.x*0.5, 6, ball.position.z+12), 0.1);
    } else {
        camera.position.lerp(new THREE.Vector3(0, 6, 32), 0.1);
    }
    camera.lookAt(0, 2, PHYS.GOAL_Z);
    renderer.render(scene, camera);
}

reset();
update();
</script>
</body>
</html>
