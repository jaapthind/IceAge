<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Monster Penalty: Drag & Aim</title>
    <style>
        body { margin: 0; overflow: hidden; background: #022c22; font-family: 'Arial Black', sans-serif; touch-action: none; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .hud { position: absolute; color: #facc15; text-shadow: 3px 3px 0px #000; font-style: italic; font-weight: 900; }
        #stats { top: 20px; left: 20px; font-size: 30px; color: white; }
        #power-ui { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); font-size: 24px; display: none; }
        #msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 100px; text-align: center; display: none; }
        #hint { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.6); font-size: 18px; }
    </style>
</head>
<body>
<div id="ui">
    <div id="stats" class="hud">GOALS: 0</div>
    <div id="msg" class="hud">GOAL!</div>
    <div id="power-ui" class="hud">POWER: <span id="p-val">0</span>%</div>
    <div id="hint" class="hud">DRAG BACK FROM BALL TO AIM & POWER UP</div>
</div>
<canvas id="game"></canvas>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

// --- INITIALIZATION ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x022c22);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- LIGHTING ---
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const spot = new THREE.SpotLight(0xffffff, 5000);
spot.position.set(0, 50, 20);
spot.castShadow = true;
scene.add(spot);

// --- STADIUM ---
const grass = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x14532d }));
grass.rotation.x = -Math.PI / 2;
grass.receiveShadow = true;
scene.add(grass);

// Goal Structure
const goal = new THREE.Group();
const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
const createPart = (w,h,d,x,y,z) => {
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), postMat);
    m.position.set(x,y,z); m.castShadow = true; goal.add(m);
};
createPart(0.6, 12, 0.6, -12, 6, -40);
createPart(0.6, 12, 0.6, 12, 6, -40);
createPart(24.6, 0.6, 0.6, 0, 12, -40);
scene.add(goal);

// Ball
const ball = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
ball.position.set(0, 0.8, 15);
ball.castShadow = true;
scene.add(ball);

// Aimer Line
let aimerLine = new THREE.Line();
const aimerMat = new THREE.LineBasicMaterial({ color: 0xfacc15, linewidth: 3 });

// --- INTERACTION LOGIC ---
let isDragging = false;
let isLaunched = false;
let goals = 0;
let dragStart = new THREE.Vector2();
let dragCurrent = new THREE.Vector2();
let launchVec = new THREE.Vector3();
let currentPower = 0;

camera.position.set(0, 8, 35);
camera.lookAt(0, 4, -10);

const pVal = document.getElementById('p-val');
const pUI = document.getElementById('power-ui');
const msg = document.getElementById('msg');

// Mouse/Touch translation
const getMousePos = (e) => {
    const x = (e.touches ? e.touches[0].clientX : e.clientX);
    const y = (e.touches ? e.touches[0].clientY : e.clientY);
    return new THREE.Vector2(x, y);
};

window.addEventListener('mousedown', (e) => {
    if (isLaunched) return;
    isDragging = true;
    dragStart = getMousePos(e);
    pUI.style.display = 'block';
});

window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    dragCurrent = getMousePos(e);
    
    // Calculate vector from drag
    const dx = dragStart.x - dragCurrent.x;
    const dy = dragStart.y - dragCurrent.y;
    
    currentPower = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.5, 100);
    pVal.innerText = Math.floor(currentPower);

    // Update 3D Aimer
    scene.remove(aimerLine);
    const points = [];
    let tempPos = ball.position.clone();
    let tempVel = new THREE.Vector3(dx * 0.02, dy * 0.04, -currentPower * 0.3);
    
    for(let i=0; i<25; i++) {
        points.push(tempPos.clone());
        tempPos.add(tempVel);
        tempVel.y -= 0.015; // Gravity
    }
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    aimerLine = new THREE.Line(geo, aimerMat);
    scene.add(aimerLine);
    
    launchVec.copy(new THREE.Vector3(dx * 0.02, dy * 0.04, -currentPower * 0.3));
});

window.addEventListener('mouseup', () => {
    if (!isDragging) return;
    isDragging = false;
    isLaunched = true;
    pUI.style.display = 'none';
    scene.remove(aimerLine);
});

// --- GAME LOOP ---
function reset() {
    isLaunched = false;
    ball.position.set(0, 0.8, 15);
    launchVec.set(0,0,0);
    msg.style.display = 'none';
}

function animate() {
    requestAnimationFrame(animate);
    
    if (isLaunched) {
        ball.position.add(launchVec);
        launchVec.y -= 0.015; // Gravity
        ball.rotation.x += launchVec.z * 0.1;

        if (ball.position.y < 0.8) {
            ball.position.y = 0.8;
            launchVec.y *= -0.4;
        }

        // Infinite Goal Logic
        if (ball.position.z < -40) {
            if (Math.abs(ball.position.x) < 12 && ball.position.y < 12) {
                goals++;
                document.getElementById('stats').innerText = "GOALS: " + goals;
                msg.innerText = "GOAL!";
            } else {
                msg.innerText = "MISS!";
            }
            msg.style.display = 'block';
            isLaunched = false;
            setTimeout(reset, 1500);
        }
    }
    renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
